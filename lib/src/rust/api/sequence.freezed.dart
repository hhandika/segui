// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sequence.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$FilteringParams {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(BigInt field0) alnLen,
    required TResult Function(BigInt field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(BigInt field0)? alnLen,
    TResult? Function(BigInt field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(BigInt field0)? alnLen,
    TResult Function(BigInt field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FilteringParamsCopyWith<$Res> {
  factory $FilteringParamsCopyWith(
          FilteringParams value, $Res Function(FilteringParams) then) =
      _$FilteringParamsCopyWithImpl<$Res, FilteringParams>;
}

/// @nodoc
class _$FilteringParamsCopyWithImpl<$Res, $Val extends FilteringParams>
    implements $FilteringParamsCopyWith<$Res> {
  _$FilteringParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$FilteringParams_MinTaxImplCopyWith<$Res> {
  factory _$$FilteringParams_MinTaxImplCopyWith(
          _$FilteringParams_MinTaxImpl value,
          $Res Function(_$FilteringParams_MinTaxImpl) then) =
      __$$FilteringParams_MinTaxImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$FilteringParams_MinTaxImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_MinTaxImpl>
    implements _$$FilteringParams_MinTaxImplCopyWith<$Res> {
  __$$FilteringParams_MinTaxImplCopyWithImpl(
      _$FilteringParams_MinTaxImpl _value,
      $Res Function(_$FilteringParams_MinTaxImpl) _then)
      : super(_value, _then);

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FilteringParams_MinTaxImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$FilteringParams_MinTaxImpl extends FilteringParams_MinTax {
  const _$FilteringParams_MinTaxImpl(this.field0) : super._();

  @override
  final double field0;

  @override
  String toString() {
    return 'FilteringParams.minTax(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_MinTaxImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FilteringParams_MinTaxImplCopyWith<_$FilteringParams_MinTaxImpl>
      get copyWith => __$$FilteringParams_MinTaxImplCopyWithImpl<
          _$FilteringParams_MinTaxImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(BigInt field0) alnLen,
    required TResult Function(BigInt field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return minTax(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(BigInt field0)? alnLen,
    TResult? Function(BigInt field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return minTax?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(BigInt field0)? alnLen,
    TResult Function(BigInt field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (minTax != null) {
      return minTax(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return minTax(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return minTax?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (minTax != null) {
      return minTax(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_MinTax extends FilteringParams {
  const factory FilteringParams_MinTax(final double field0) =
      _$FilteringParams_MinTaxImpl;
  const FilteringParams_MinTax._() : super._();

  double get field0;

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FilteringParams_MinTaxImplCopyWith<_$FilteringParams_MinTaxImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FilteringParams_AlnLenImplCopyWith<$Res> {
  factory _$$FilteringParams_AlnLenImplCopyWith(
          _$FilteringParams_AlnLenImpl value,
          $Res Function(_$FilteringParams_AlnLenImpl) then) =
      __$$FilteringParams_AlnLenImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt field0});
}

/// @nodoc
class __$$FilteringParams_AlnLenImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_AlnLenImpl>
    implements _$$FilteringParams_AlnLenImplCopyWith<$Res> {
  __$$FilteringParams_AlnLenImplCopyWithImpl(
      _$FilteringParams_AlnLenImpl _value,
      $Res Function(_$FilteringParams_AlnLenImpl) _then)
      : super(_value, _then);

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FilteringParams_AlnLenImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$FilteringParams_AlnLenImpl extends FilteringParams_AlnLen {
  const _$FilteringParams_AlnLenImpl(this.field0) : super._();

  @override
  final BigInt field0;

  @override
  String toString() {
    return 'FilteringParams.alnLen(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_AlnLenImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FilteringParams_AlnLenImplCopyWith<_$FilteringParams_AlnLenImpl>
      get copyWith => __$$FilteringParams_AlnLenImplCopyWithImpl<
          _$FilteringParams_AlnLenImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(BigInt field0) alnLen,
    required TResult Function(BigInt field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return alnLen(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(BigInt field0)? alnLen,
    TResult? Function(BigInt field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return alnLen?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(BigInt field0)? alnLen,
    TResult Function(BigInt field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (alnLen != null) {
      return alnLen(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return alnLen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return alnLen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (alnLen != null) {
      return alnLen(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_AlnLen extends FilteringParams {
  const factory FilteringParams_AlnLen(final BigInt field0) =
      _$FilteringParams_AlnLenImpl;
  const FilteringParams_AlnLen._() : super._();

  BigInt get field0;

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FilteringParams_AlnLenImplCopyWith<_$FilteringParams_AlnLenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FilteringParams_ParsInfImplCopyWith<$Res> {
  factory _$$FilteringParams_ParsInfImplCopyWith(
          _$FilteringParams_ParsInfImpl value,
          $Res Function(_$FilteringParams_ParsInfImpl) then) =
      __$$FilteringParams_ParsInfImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt field0});
}

/// @nodoc
class __$$FilteringParams_ParsInfImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_ParsInfImpl>
    implements _$$FilteringParams_ParsInfImplCopyWith<$Res> {
  __$$FilteringParams_ParsInfImplCopyWithImpl(
      _$FilteringParams_ParsInfImpl _value,
      $Res Function(_$FilteringParams_ParsInfImpl) _then)
      : super(_value, _then);

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FilteringParams_ParsInfImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$FilteringParams_ParsInfImpl extends FilteringParams_ParsInf {
  const _$FilteringParams_ParsInfImpl(this.field0) : super._();

  @override
  final BigInt field0;

  @override
  String toString() {
    return 'FilteringParams.parsInf(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_ParsInfImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FilteringParams_ParsInfImplCopyWith<_$FilteringParams_ParsInfImpl>
      get copyWith => __$$FilteringParams_ParsInfImplCopyWithImpl<
          _$FilteringParams_ParsInfImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(BigInt field0) alnLen,
    required TResult Function(BigInt field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return parsInf(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(BigInt field0)? alnLen,
    TResult? Function(BigInt field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return parsInf?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(BigInt field0)? alnLen,
    TResult Function(BigInt field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (parsInf != null) {
      return parsInf(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return parsInf(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return parsInf?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (parsInf != null) {
      return parsInf(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_ParsInf extends FilteringParams {
  const factory FilteringParams_ParsInf(final BigInt field0) =
      _$FilteringParams_ParsInfImpl;
  const FilteringParams_ParsInf._() : super._();

  BigInt get field0;

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FilteringParams_ParsInfImplCopyWith<_$FilteringParams_ParsInfImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FilteringParams_PercInfImplCopyWith<$Res> {
  factory _$$FilteringParams_PercInfImplCopyWith(
          _$FilteringParams_PercInfImpl value,
          $Res Function(_$FilteringParams_PercInfImpl) then) =
      __$$FilteringParams_PercInfImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$FilteringParams_PercInfImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_PercInfImpl>
    implements _$$FilteringParams_PercInfImplCopyWith<$Res> {
  __$$FilteringParams_PercInfImplCopyWithImpl(
      _$FilteringParams_PercInfImpl _value,
      $Res Function(_$FilteringParams_PercInfImpl) _then)
      : super(_value, _then);

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FilteringParams_PercInfImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$FilteringParams_PercInfImpl extends FilteringParams_PercInf {
  const _$FilteringParams_PercInfImpl(this.field0) : super._();

  @override
  final double field0;

  @override
  String toString() {
    return 'FilteringParams.percInf(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_PercInfImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FilteringParams_PercInfImplCopyWith<_$FilteringParams_PercInfImpl>
      get copyWith => __$$FilteringParams_PercInfImplCopyWithImpl<
          _$FilteringParams_PercInfImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(BigInt field0) alnLen,
    required TResult Function(BigInt field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return percInf(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(BigInt field0)? alnLen,
    TResult? Function(BigInt field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return percInf?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(BigInt field0)? alnLen,
    TResult Function(BigInt field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (percInf != null) {
      return percInf(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return percInf(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return percInf?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (percInf != null) {
      return percInf(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_PercInf extends FilteringParams {
  const factory FilteringParams_PercInf(final double field0) =
      _$FilteringParams_PercInfImpl;
  const FilteringParams_PercInf._() : super._();

  double get field0;

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FilteringParams_PercInfImplCopyWith<_$FilteringParams_PercInfImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FilteringParams_TaxonAllImplCopyWith<$Res> {
  factory _$$FilteringParams_TaxonAllImplCopyWith(
          _$FilteringParams_TaxonAllImpl value,
          $Res Function(_$FilteringParams_TaxonAllImpl) then) =
      __$$FilteringParams_TaxonAllImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> field0});
}

/// @nodoc
class __$$FilteringParams_TaxonAllImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_TaxonAllImpl>
    implements _$$FilteringParams_TaxonAllImplCopyWith<$Res> {
  __$$FilteringParams_TaxonAllImplCopyWithImpl(
      _$FilteringParams_TaxonAllImpl _value,
      $Res Function(_$FilteringParams_TaxonAllImpl) _then)
      : super(_value, _then);

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FilteringParams_TaxonAllImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$FilteringParams_TaxonAllImpl extends FilteringParams_TaxonAll {
  const _$FilteringParams_TaxonAllImpl(final List<String> field0)
      : _field0 = field0,
        super._();

  final List<String> _field0;
  @override
  List<String> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'FilteringParams.taxonAll(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_TaxonAllImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FilteringParams_TaxonAllImplCopyWith<_$FilteringParams_TaxonAllImpl>
      get copyWith => __$$FilteringParams_TaxonAllImplCopyWithImpl<
          _$FilteringParams_TaxonAllImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(BigInt field0) alnLen,
    required TResult Function(BigInt field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return taxonAll(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(BigInt field0)? alnLen,
    TResult? Function(BigInt field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return taxonAll?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(BigInt field0)? alnLen,
    TResult Function(BigInt field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (taxonAll != null) {
      return taxonAll(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return taxonAll(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return taxonAll?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (taxonAll != null) {
      return taxonAll(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_TaxonAll extends FilteringParams {
  const factory FilteringParams_TaxonAll(final List<String> field0) =
      _$FilteringParams_TaxonAllImpl;
  const FilteringParams_TaxonAll._() : super._();

  List<String> get field0;

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FilteringParams_TaxonAllImplCopyWith<_$FilteringParams_TaxonAllImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FilteringParams_NoneImplCopyWith<$Res> {
  factory _$$FilteringParams_NoneImplCopyWith(_$FilteringParams_NoneImpl value,
          $Res Function(_$FilteringParams_NoneImpl) then) =
      __$$FilteringParams_NoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FilteringParams_NoneImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_NoneImpl>
    implements _$$FilteringParams_NoneImplCopyWith<$Res> {
  __$$FilteringParams_NoneImplCopyWithImpl(_$FilteringParams_NoneImpl _value,
      $Res Function(_$FilteringParams_NoneImpl) _then)
      : super(_value, _then);

  /// Create a copy of FilteringParams
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FilteringParams_NoneImpl extends FilteringParams_None {
  const _$FilteringParams_NoneImpl() : super._();

  @override
  String toString() {
    return 'FilteringParams.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_NoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(BigInt field0) alnLen,
    required TResult Function(BigInt field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(BigInt field0)? alnLen,
    TResult? Function(BigInt field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(BigInt field0)? alnLen,
    TResult Function(BigInt field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_None extends FilteringParams {
  const factory FilteringParams_None() = _$FilteringParams_NoneImpl;
  const FilteringParams_None._() : super._();
}

/// @nodoc
mixin _$SequenceExtractionParams {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> field0) id,
    required TResult Function(String field0) file,
    required TResult Function(String field0) regex,
    required TResult Function() none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> field0)? id,
    TResult? Function(String field0)? file,
    TResult? Function(String field0)? regex,
    TResult? Function()? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> field0)? id,
    TResult Function(String field0)? file,
    TResult Function(String field0)? regex,
    TResult Function()? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceExtractionParams_Id value) id,
    required TResult Function(SequenceExtractionParams_File value) file,
    required TResult Function(SequenceExtractionParams_Regex value) regex,
    required TResult Function(SequenceExtractionParams_None value) none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceExtractionParams_Id value)? id,
    TResult? Function(SequenceExtractionParams_File value)? file,
    TResult? Function(SequenceExtractionParams_Regex value)? regex,
    TResult? Function(SequenceExtractionParams_None value)? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceExtractionParams_Id value)? id,
    TResult Function(SequenceExtractionParams_File value)? file,
    TResult Function(SequenceExtractionParams_Regex value)? regex,
    TResult Function(SequenceExtractionParams_None value)? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SequenceExtractionParamsCopyWith<$Res> {
  factory $SequenceExtractionParamsCopyWith(SequenceExtractionParams value,
          $Res Function(SequenceExtractionParams) then) =
      _$SequenceExtractionParamsCopyWithImpl<$Res, SequenceExtractionParams>;
}

/// @nodoc
class _$SequenceExtractionParamsCopyWithImpl<$Res,
        $Val extends SequenceExtractionParams>
    implements $SequenceExtractionParamsCopyWith<$Res> {
  _$SequenceExtractionParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SequenceExtractionParams_IdImplCopyWith<$Res> {
  factory _$$SequenceExtractionParams_IdImplCopyWith(
          _$SequenceExtractionParams_IdImpl value,
          $Res Function(_$SequenceExtractionParams_IdImpl) then) =
      __$$SequenceExtractionParams_IdImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> field0});
}

/// @nodoc
class __$$SequenceExtractionParams_IdImplCopyWithImpl<$Res>
    extends _$SequenceExtractionParamsCopyWithImpl<$Res,
        _$SequenceExtractionParams_IdImpl>
    implements _$$SequenceExtractionParams_IdImplCopyWith<$Res> {
  __$$SequenceExtractionParams_IdImplCopyWithImpl(
      _$SequenceExtractionParams_IdImpl _value,
      $Res Function(_$SequenceExtractionParams_IdImpl) _then)
      : super(_value, _then);

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SequenceExtractionParams_IdImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$SequenceExtractionParams_IdImpl extends SequenceExtractionParams_Id {
  const _$SequenceExtractionParams_IdImpl(final List<String> field0)
      : _field0 = field0,
        super._();

  final List<String> _field0;
  @override
  List<String> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'SequenceExtractionParams.id(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceExtractionParams_IdImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceExtractionParams_IdImplCopyWith<_$SequenceExtractionParams_IdImpl>
      get copyWith => __$$SequenceExtractionParams_IdImplCopyWithImpl<
          _$SequenceExtractionParams_IdImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> field0) id,
    required TResult Function(String field0) file,
    required TResult Function(String field0) regex,
    required TResult Function() none,
  }) {
    return id(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> field0)? id,
    TResult? Function(String field0)? file,
    TResult? Function(String field0)? regex,
    TResult? Function()? none,
  }) {
    return id?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> field0)? id,
    TResult Function(String field0)? file,
    TResult Function(String field0)? regex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (id != null) {
      return id(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceExtractionParams_Id value) id,
    required TResult Function(SequenceExtractionParams_File value) file,
    required TResult Function(SequenceExtractionParams_Regex value) regex,
    required TResult Function(SequenceExtractionParams_None value) none,
  }) {
    return id(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceExtractionParams_Id value)? id,
    TResult? Function(SequenceExtractionParams_File value)? file,
    TResult? Function(SequenceExtractionParams_Regex value)? regex,
    TResult? Function(SequenceExtractionParams_None value)? none,
  }) {
    return id?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceExtractionParams_Id value)? id,
    TResult Function(SequenceExtractionParams_File value)? file,
    TResult Function(SequenceExtractionParams_Regex value)? regex,
    TResult Function(SequenceExtractionParams_None value)? none,
    required TResult orElse(),
  }) {
    if (id != null) {
      return id(this);
    }
    return orElse();
  }
}

abstract class SequenceExtractionParams_Id extends SequenceExtractionParams {
  const factory SequenceExtractionParams_Id(final List<String> field0) =
      _$SequenceExtractionParams_IdImpl;
  const SequenceExtractionParams_Id._() : super._();

  List<String> get field0;

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SequenceExtractionParams_IdImplCopyWith<_$SequenceExtractionParams_IdImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceExtractionParams_FileImplCopyWith<$Res> {
  factory _$$SequenceExtractionParams_FileImplCopyWith(
          _$SequenceExtractionParams_FileImpl value,
          $Res Function(_$SequenceExtractionParams_FileImpl) then) =
      __$$SequenceExtractionParams_FileImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$SequenceExtractionParams_FileImplCopyWithImpl<$Res>
    extends _$SequenceExtractionParamsCopyWithImpl<$Res,
        _$SequenceExtractionParams_FileImpl>
    implements _$$SequenceExtractionParams_FileImplCopyWith<$Res> {
  __$$SequenceExtractionParams_FileImplCopyWithImpl(
      _$SequenceExtractionParams_FileImpl _value,
      $Res Function(_$SequenceExtractionParams_FileImpl) _then)
      : super(_value, _then);

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SequenceExtractionParams_FileImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SequenceExtractionParams_FileImpl
    extends SequenceExtractionParams_File {
  const _$SequenceExtractionParams_FileImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'SequenceExtractionParams.file(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceExtractionParams_FileImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceExtractionParams_FileImplCopyWith<
          _$SequenceExtractionParams_FileImpl>
      get copyWith => __$$SequenceExtractionParams_FileImplCopyWithImpl<
          _$SequenceExtractionParams_FileImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> field0) id,
    required TResult Function(String field0) file,
    required TResult Function(String field0) regex,
    required TResult Function() none,
  }) {
    return file(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> field0)? id,
    TResult? Function(String field0)? file,
    TResult? Function(String field0)? regex,
    TResult? Function()? none,
  }) {
    return file?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> field0)? id,
    TResult Function(String field0)? file,
    TResult Function(String field0)? regex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (file != null) {
      return file(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceExtractionParams_Id value) id,
    required TResult Function(SequenceExtractionParams_File value) file,
    required TResult Function(SequenceExtractionParams_Regex value) regex,
    required TResult Function(SequenceExtractionParams_None value) none,
  }) {
    return file(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceExtractionParams_Id value)? id,
    TResult? Function(SequenceExtractionParams_File value)? file,
    TResult? Function(SequenceExtractionParams_Regex value)? regex,
    TResult? Function(SequenceExtractionParams_None value)? none,
  }) {
    return file?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceExtractionParams_Id value)? id,
    TResult Function(SequenceExtractionParams_File value)? file,
    TResult Function(SequenceExtractionParams_Regex value)? regex,
    TResult Function(SequenceExtractionParams_None value)? none,
    required TResult orElse(),
  }) {
    if (file != null) {
      return file(this);
    }
    return orElse();
  }
}

abstract class SequenceExtractionParams_File extends SequenceExtractionParams {
  const factory SequenceExtractionParams_File(final String field0) =
      _$SequenceExtractionParams_FileImpl;
  const SequenceExtractionParams_File._() : super._();

  String get field0;

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SequenceExtractionParams_FileImplCopyWith<
          _$SequenceExtractionParams_FileImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceExtractionParams_RegexImplCopyWith<$Res> {
  factory _$$SequenceExtractionParams_RegexImplCopyWith(
          _$SequenceExtractionParams_RegexImpl value,
          $Res Function(_$SequenceExtractionParams_RegexImpl) then) =
      __$$SequenceExtractionParams_RegexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$SequenceExtractionParams_RegexImplCopyWithImpl<$Res>
    extends _$SequenceExtractionParamsCopyWithImpl<$Res,
        _$SequenceExtractionParams_RegexImpl>
    implements _$$SequenceExtractionParams_RegexImplCopyWith<$Res> {
  __$$SequenceExtractionParams_RegexImplCopyWithImpl(
      _$SequenceExtractionParams_RegexImpl _value,
      $Res Function(_$SequenceExtractionParams_RegexImpl) _then)
      : super(_value, _then);

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SequenceExtractionParams_RegexImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SequenceExtractionParams_RegexImpl
    extends SequenceExtractionParams_Regex {
  const _$SequenceExtractionParams_RegexImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'SequenceExtractionParams.regex(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceExtractionParams_RegexImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceExtractionParams_RegexImplCopyWith<
          _$SequenceExtractionParams_RegexImpl>
      get copyWith => __$$SequenceExtractionParams_RegexImplCopyWithImpl<
          _$SequenceExtractionParams_RegexImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> field0) id,
    required TResult Function(String field0) file,
    required TResult Function(String field0) regex,
    required TResult Function() none,
  }) {
    return regex(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> field0)? id,
    TResult? Function(String field0)? file,
    TResult? Function(String field0)? regex,
    TResult? Function()? none,
  }) {
    return regex?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> field0)? id,
    TResult Function(String field0)? file,
    TResult Function(String field0)? regex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (regex != null) {
      return regex(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceExtractionParams_Id value) id,
    required TResult Function(SequenceExtractionParams_File value) file,
    required TResult Function(SequenceExtractionParams_Regex value) regex,
    required TResult Function(SequenceExtractionParams_None value) none,
  }) {
    return regex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceExtractionParams_Id value)? id,
    TResult? Function(SequenceExtractionParams_File value)? file,
    TResult? Function(SequenceExtractionParams_Regex value)? regex,
    TResult? Function(SequenceExtractionParams_None value)? none,
  }) {
    return regex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceExtractionParams_Id value)? id,
    TResult Function(SequenceExtractionParams_File value)? file,
    TResult Function(SequenceExtractionParams_Regex value)? regex,
    TResult Function(SequenceExtractionParams_None value)? none,
    required TResult orElse(),
  }) {
    if (regex != null) {
      return regex(this);
    }
    return orElse();
  }
}

abstract class SequenceExtractionParams_Regex extends SequenceExtractionParams {
  const factory SequenceExtractionParams_Regex(final String field0) =
      _$SequenceExtractionParams_RegexImpl;
  const SequenceExtractionParams_Regex._() : super._();

  String get field0;

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SequenceExtractionParams_RegexImplCopyWith<
          _$SequenceExtractionParams_RegexImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceExtractionParams_NoneImplCopyWith<$Res> {
  factory _$$SequenceExtractionParams_NoneImplCopyWith(
          _$SequenceExtractionParams_NoneImpl value,
          $Res Function(_$SequenceExtractionParams_NoneImpl) then) =
      __$$SequenceExtractionParams_NoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SequenceExtractionParams_NoneImplCopyWithImpl<$Res>
    extends _$SequenceExtractionParamsCopyWithImpl<$Res,
        _$SequenceExtractionParams_NoneImpl>
    implements _$$SequenceExtractionParams_NoneImplCopyWith<$Res> {
  __$$SequenceExtractionParams_NoneImplCopyWithImpl(
      _$SequenceExtractionParams_NoneImpl _value,
      $Res Function(_$SequenceExtractionParams_NoneImpl) _then)
      : super(_value, _then);

  /// Create a copy of SequenceExtractionParams
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SequenceExtractionParams_NoneImpl
    extends SequenceExtractionParams_None {
  const _$SequenceExtractionParams_NoneImpl() : super._();

  @override
  String toString() {
    return 'SequenceExtractionParams.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceExtractionParams_NoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> field0) id,
    required TResult Function(String field0) file,
    required TResult Function(String field0) regex,
    required TResult Function() none,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> field0)? id,
    TResult? Function(String field0)? file,
    TResult? Function(String field0)? regex,
    TResult? Function()? none,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> field0)? id,
    TResult Function(String field0)? file,
    TResult Function(String field0)? regex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceExtractionParams_Id value) id,
    required TResult Function(SequenceExtractionParams_File value) file,
    required TResult Function(SequenceExtractionParams_Regex value) regex,
    required TResult Function(SequenceExtractionParams_None value) none,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceExtractionParams_Id value)? id,
    TResult? Function(SequenceExtractionParams_File value)? file,
    TResult? Function(SequenceExtractionParams_Regex value)? regex,
    TResult? Function(SequenceExtractionParams_None value)? none,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceExtractionParams_Id value)? id,
    TResult Function(SequenceExtractionParams_File value)? file,
    TResult Function(SequenceExtractionParams_Regex value)? regex,
    TResult Function(SequenceExtractionParams_None value)? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class SequenceExtractionParams_None extends SequenceExtractionParams {
  const factory SequenceExtractionParams_None() =
      _$SequenceExtractionParams_NoneImpl;
  const SequenceExtractionParams_None._() : super._();
}

/// @nodoc
mixin _$SequenceRenamingParams {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SequenceRenamingParamsCopyWith<$Res> {
  factory $SequenceRenamingParamsCopyWith(SequenceRenamingParams value,
          $Res Function(SequenceRenamingParams) then) =
      _$SequenceRenamingParamsCopyWithImpl<$Res, SequenceRenamingParams>;
}

/// @nodoc
class _$SequenceRenamingParamsCopyWithImpl<$Res,
        $Val extends SequenceRenamingParams>
    implements $SequenceRenamingParamsCopyWith<$Res> {
  _$SequenceRenamingParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SequenceRenamingParams_RenameIdImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_RenameIdImplCopyWith(
          _$SequenceRenamingParams_RenameIdImpl value,
          $Res Function(_$SequenceRenamingParams_RenameIdImpl) then) =
      __$$SequenceRenamingParams_RenameIdImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$SequenceRenamingParams_RenameIdImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_RenameIdImpl>
    implements _$$SequenceRenamingParams_RenameIdImplCopyWith<$Res> {
  __$$SequenceRenamingParams_RenameIdImplCopyWithImpl(
      _$SequenceRenamingParams_RenameIdImpl _value,
      $Res Function(_$SequenceRenamingParams_RenameIdImpl) _then)
      : super(_value, _then);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SequenceRenamingParams_RenameIdImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SequenceRenamingParams_RenameIdImpl
    extends SequenceRenamingParams_RenameId {
  const _$SequenceRenamingParams_RenameIdImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'SequenceRenamingParams.renameId(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_RenameIdImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceRenamingParams_RenameIdImplCopyWith<
          _$SequenceRenamingParams_RenameIdImpl>
      get copyWith => __$$SequenceRenamingParams_RenameIdImplCopyWithImpl<
          _$SequenceRenamingParams_RenameIdImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return renameId(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return renameId?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (renameId != null) {
      return renameId(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return renameId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return renameId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (renameId != null) {
      return renameId(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_RenameId extends SequenceRenamingParams {
  const factory SequenceRenamingParams_RenameId(final String field0) =
      _$SequenceRenamingParams_RenameIdImpl;
  const SequenceRenamingParams_RenameId._() : super._();

  String get field0;

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SequenceRenamingParams_RenameIdImplCopyWith<
          _$SequenceRenamingParams_RenameIdImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_RemoveStrImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_RemoveStrImplCopyWith(
          _$SequenceRenamingParams_RemoveStrImpl value,
          $Res Function(_$SequenceRenamingParams_RemoveStrImpl) then) =
      __$$SequenceRenamingParams_RemoveStrImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$SequenceRenamingParams_RemoveStrImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_RemoveStrImpl>
    implements _$$SequenceRenamingParams_RemoveStrImplCopyWith<$Res> {
  __$$SequenceRenamingParams_RemoveStrImplCopyWithImpl(
      _$SequenceRenamingParams_RemoveStrImpl _value,
      $Res Function(_$SequenceRenamingParams_RemoveStrImpl) _then)
      : super(_value, _then);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SequenceRenamingParams_RemoveStrImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SequenceRenamingParams_RemoveStrImpl
    extends SequenceRenamingParams_RemoveStr {
  const _$SequenceRenamingParams_RemoveStrImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'SequenceRenamingParams.removeStr(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_RemoveStrImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceRenamingParams_RemoveStrImplCopyWith<
          _$SequenceRenamingParams_RemoveStrImpl>
      get copyWith => __$$SequenceRenamingParams_RemoveStrImplCopyWithImpl<
          _$SequenceRenamingParams_RemoveStrImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return removeStr(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return removeStr?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (removeStr != null) {
      return removeStr(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return removeStr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return removeStr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (removeStr != null) {
      return removeStr(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_RemoveStr extends SequenceRenamingParams {
  const factory SequenceRenamingParams_RemoveStr(final String field0) =
      _$SequenceRenamingParams_RemoveStrImpl;
  const SequenceRenamingParams_RemoveStr._() : super._();

  String get field0;

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SequenceRenamingParams_RemoveStrImplCopyWith<
          _$SequenceRenamingParams_RemoveStrImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_RemoveRegexImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_RemoveRegexImplCopyWith(
          _$SequenceRenamingParams_RemoveRegexImpl value,
          $Res Function(_$SequenceRenamingParams_RemoveRegexImpl) then) =
      __$$SequenceRenamingParams_RemoveRegexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0, bool field1});
}

/// @nodoc
class __$$SequenceRenamingParams_RemoveRegexImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_RemoveRegexImpl>
    implements _$$SequenceRenamingParams_RemoveRegexImplCopyWith<$Res> {
  __$$SequenceRenamingParams_RemoveRegexImplCopyWithImpl(
      _$SequenceRenamingParams_RemoveRegexImpl _value,
      $Res Function(_$SequenceRenamingParams_RemoveRegexImpl) _then)
      : super(_value, _then);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$SequenceRenamingParams_RemoveRegexImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$SequenceRenamingParams_RemoveRegexImpl
    extends SequenceRenamingParams_RemoveRegex {
  const _$SequenceRenamingParams_RemoveRegexImpl(this.field0, this.field1)
      : super._();

  @override
  final String field0;
  @override
  final bool field1;

  @override
  String toString() {
    return 'SequenceRenamingParams.removeRegex(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_RemoveRegexImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceRenamingParams_RemoveRegexImplCopyWith<
          _$SequenceRenamingParams_RemoveRegexImpl>
      get copyWith => __$$SequenceRenamingParams_RemoveRegexImplCopyWithImpl<
          _$SequenceRenamingParams_RemoveRegexImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return removeRegex(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return removeRegex?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (removeRegex != null) {
      return removeRegex(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return removeRegex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return removeRegex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (removeRegex != null) {
      return removeRegex(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_RemoveRegex
    extends SequenceRenamingParams {
  const factory SequenceRenamingParams_RemoveRegex(
          final String field0, final bool field1) =
      _$SequenceRenamingParams_RemoveRegexImpl;
  const SequenceRenamingParams_RemoveRegex._() : super._();

  String get field0;
  bool get field1;

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SequenceRenamingParams_RemoveRegexImplCopyWith<
          _$SequenceRenamingParams_RemoveRegexImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_ReplaceStrImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_ReplaceStrImplCopyWith(
          _$SequenceRenamingParams_ReplaceStrImpl value,
          $Res Function(_$SequenceRenamingParams_ReplaceStrImpl) then) =
      __$$SequenceRenamingParams_ReplaceStrImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0, String field1});
}

/// @nodoc
class __$$SequenceRenamingParams_ReplaceStrImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_ReplaceStrImpl>
    implements _$$SequenceRenamingParams_ReplaceStrImplCopyWith<$Res> {
  __$$SequenceRenamingParams_ReplaceStrImplCopyWithImpl(
      _$SequenceRenamingParams_ReplaceStrImpl _value,
      $Res Function(_$SequenceRenamingParams_ReplaceStrImpl) _then)
      : super(_value, _then);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$SequenceRenamingParams_ReplaceStrImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SequenceRenamingParams_ReplaceStrImpl
    extends SequenceRenamingParams_ReplaceStr {
  const _$SequenceRenamingParams_ReplaceStrImpl(this.field0, this.field1)
      : super._();

  @override
  final String field0;
  @override
  final String field1;

  @override
  String toString() {
    return 'SequenceRenamingParams.replaceStr(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_ReplaceStrImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceRenamingParams_ReplaceStrImplCopyWith<
          _$SequenceRenamingParams_ReplaceStrImpl>
      get copyWith => __$$SequenceRenamingParams_ReplaceStrImplCopyWithImpl<
          _$SequenceRenamingParams_ReplaceStrImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return replaceStr(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return replaceStr?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (replaceStr != null) {
      return replaceStr(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return replaceStr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return replaceStr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (replaceStr != null) {
      return replaceStr(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_ReplaceStr
    extends SequenceRenamingParams {
  const factory SequenceRenamingParams_ReplaceStr(
          final String field0, final String field1) =
      _$SequenceRenamingParams_ReplaceStrImpl;
  const SequenceRenamingParams_ReplaceStr._() : super._();

  String get field0;
  String get field1;

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SequenceRenamingParams_ReplaceStrImplCopyWith<
          _$SequenceRenamingParams_ReplaceStrImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_ReplaceRegexImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_ReplaceRegexImplCopyWith(
          _$SequenceRenamingParams_ReplaceRegexImpl value,
          $Res Function(_$SequenceRenamingParams_ReplaceRegexImpl) then) =
      __$$SequenceRenamingParams_ReplaceRegexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0, String field1, bool field2});
}

/// @nodoc
class __$$SequenceRenamingParams_ReplaceRegexImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_ReplaceRegexImpl>
    implements _$$SequenceRenamingParams_ReplaceRegexImplCopyWith<$Res> {
  __$$SequenceRenamingParams_ReplaceRegexImplCopyWithImpl(
      _$SequenceRenamingParams_ReplaceRegexImpl _value,
      $Res Function(_$SequenceRenamingParams_ReplaceRegexImpl) _then)
      : super(_value, _then);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
    Object? field2 = null,
  }) {
    return _then(_$SequenceRenamingParams_ReplaceRegexImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field2
          ? _value.field2
          : field2 // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$SequenceRenamingParams_ReplaceRegexImpl
    extends SequenceRenamingParams_ReplaceRegex {
  const _$SequenceRenamingParams_ReplaceRegexImpl(
      this.field0, this.field1, this.field2)
      : super._();

  @override
  final String field0;
  @override
  final String field1;
  @override
  final bool field2;

  @override
  String toString() {
    return 'SequenceRenamingParams.replaceRegex(field0: $field0, field1: $field1, field2: $field2)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_ReplaceRegexImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1) &&
            (identical(other.field2, field2) || other.field2 == field2));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1, field2);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceRenamingParams_ReplaceRegexImplCopyWith<
          _$SequenceRenamingParams_ReplaceRegexImpl>
      get copyWith => __$$SequenceRenamingParams_ReplaceRegexImplCopyWithImpl<
          _$SequenceRenamingParams_ReplaceRegexImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return replaceRegex(field0, field1, field2);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return replaceRegex?.call(field0, field1, field2);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (replaceRegex != null) {
      return replaceRegex(field0, field1, field2);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return replaceRegex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return replaceRegex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (replaceRegex != null) {
      return replaceRegex(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_ReplaceRegex
    extends SequenceRenamingParams {
  const factory SequenceRenamingParams_ReplaceRegex(
          final String field0, final String field1, final bool field2) =
      _$SequenceRenamingParams_ReplaceRegexImpl;
  const SequenceRenamingParams_ReplaceRegex._() : super._();

  String get field0;
  String get field1;
  bool get field2;

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SequenceRenamingParams_ReplaceRegexImplCopyWith<
          _$SequenceRenamingParams_ReplaceRegexImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_NoneImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_NoneImplCopyWith(
          _$SequenceRenamingParams_NoneImpl value,
          $Res Function(_$SequenceRenamingParams_NoneImpl) then) =
      __$$SequenceRenamingParams_NoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SequenceRenamingParams_NoneImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_NoneImpl>
    implements _$$SequenceRenamingParams_NoneImplCopyWith<$Res> {
  __$$SequenceRenamingParams_NoneImplCopyWithImpl(
      _$SequenceRenamingParams_NoneImpl _value,
      $Res Function(_$SequenceRenamingParams_NoneImpl) _then)
      : super(_value, _then);

  /// Create a copy of SequenceRenamingParams
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SequenceRenamingParams_NoneImpl extends SequenceRenamingParams_None {
  const _$SequenceRenamingParams_NoneImpl() : super._();

  @override
  String toString() {
    return 'SequenceRenamingParams.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_NoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_None extends SequenceRenamingParams {
  const factory SequenceRenamingParams_None() =
      _$SequenceRenamingParams_NoneImpl;
  const SequenceRenamingParams_None._() : super._();
}
