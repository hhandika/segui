// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sequence.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FilteringParams {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(int field0) alnLen,
    required TResult Function(int field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(int field0)? alnLen,
    TResult? Function(int field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(int field0)? alnLen,
    TResult Function(int field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FilteringParamsCopyWith<$Res> {
  factory $FilteringParamsCopyWith(
          FilteringParams value, $Res Function(FilteringParams) then) =
      _$FilteringParamsCopyWithImpl<$Res, FilteringParams>;
}

/// @nodoc
class _$FilteringParamsCopyWithImpl<$Res, $Val extends FilteringParams>
    implements $FilteringParamsCopyWith<$Res> {
  _$FilteringParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FilteringParams_MinTaxImplCopyWith<$Res> {
  factory _$$FilteringParams_MinTaxImplCopyWith(
          _$FilteringParams_MinTaxImpl value,
          $Res Function(_$FilteringParams_MinTaxImpl) then) =
      __$$FilteringParams_MinTaxImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$FilteringParams_MinTaxImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_MinTaxImpl>
    implements _$$FilteringParams_MinTaxImplCopyWith<$Res> {
  __$$FilteringParams_MinTaxImplCopyWithImpl(
      _$FilteringParams_MinTaxImpl _value,
      $Res Function(_$FilteringParams_MinTaxImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FilteringParams_MinTaxImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$FilteringParams_MinTaxImpl implements FilteringParams_MinTax {
  const _$FilteringParams_MinTaxImpl(this.field0);

  @override
  final double field0;

  @override
  String toString() {
    return 'FilteringParams.minTax(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_MinTaxImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FilteringParams_MinTaxImplCopyWith<_$FilteringParams_MinTaxImpl>
      get copyWith => __$$FilteringParams_MinTaxImplCopyWithImpl<
          _$FilteringParams_MinTaxImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(int field0) alnLen,
    required TResult Function(int field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return minTax(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(int field0)? alnLen,
    TResult? Function(int field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return minTax?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(int field0)? alnLen,
    TResult Function(int field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (minTax != null) {
      return minTax(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return minTax(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return minTax?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (minTax != null) {
      return minTax(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_MinTax implements FilteringParams {
  const factory FilteringParams_MinTax(final double field0) =
      _$FilteringParams_MinTaxImpl;

  double get field0;
  @JsonKey(ignore: true)
  _$$FilteringParams_MinTaxImplCopyWith<_$FilteringParams_MinTaxImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FilteringParams_AlnLenImplCopyWith<$Res> {
  factory _$$FilteringParams_AlnLenImplCopyWith(
          _$FilteringParams_AlnLenImpl value,
          $Res Function(_$FilteringParams_AlnLenImpl) then) =
      __$$FilteringParams_AlnLenImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$FilteringParams_AlnLenImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_AlnLenImpl>
    implements _$$FilteringParams_AlnLenImplCopyWith<$Res> {
  __$$FilteringParams_AlnLenImplCopyWithImpl(
      _$FilteringParams_AlnLenImpl _value,
      $Res Function(_$FilteringParams_AlnLenImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FilteringParams_AlnLenImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$FilteringParams_AlnLenImpl implements FilteringParams_AlnLen {
  const _$FilteringParams_AlnLenImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'FilteringParams.alnLen(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_AlnLenImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FilteringParams_AlnLenImplCopyWith<_$FilteringParams_AlnLenImpl>
      get copyWith => __$$FilteringParams_AlnLenImplCopyWithImpl<
          _$FilteringParams_AlnLenImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(int field0) alnLen,
    required TResult Function(int field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return alnLen(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(int field0)? alnLen,
    TResult? Function(int field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return alnLen?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(int field0)? alnLen,
    TResult Function(int field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (alnLen != null) {
      return alnLen(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return alnLen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return alnLen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (alnLen != null) {
      return alnLen(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_AlnLen implements FilteringParams {
  const factory FilteringParams_AlnLen(final int field0) =
      _$FilteringParams_AlnLenImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$FilteringParams_AlnLenImplCopyWith<_$FilteringParams_AlnLenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FilteringParams_ParsInfImplCopyWith<$Res> {
  factory _$$FilteringParams_ParsInfImplCopyWith(
          _$FilteringParams_ParsInfImpl value,
          $Res Function(_$FilteringParams_ParsInfImpl) then) =
      __$$FilteringParams_ParsInfImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$FilteringParams_ParsInfImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_ParsInfImpl>
    implements _$$FilteringParams_ParsInfImplCopyWith<$Res> {
  __$$FilteringParams_ParsInfImplCopyWithImpl(
      _$FilteringParams_ParsInfImpl _value,
      $Res Function(_$FilteringParams_ParsInfImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FilteringParams_ParsInfImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$FilteringParams_ParsInfImpl implements FilteringParams_ParsInf {
  const _$FilteringParams_ParsInfImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'FilteringParams.parsInf(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_ParsInfImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FilteringParams_ParsInfImplCopyWith<_$FilteringParams_ParsInfImpl>
      get copyWith => __$$FilteringParams_ParsInfImplCopyWithImpl<
          _$FilteringParams_ParsInfImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(int field0) alnLen,
    required TResult Function(int field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return parsInf(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(int field0)? alnLen,
    TResult? Function(int field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return parsInf?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(int field0)? alnLen,
    TResult Function(int field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (parsInf != null) {
      return parsInf(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return parsInf(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return parsInf?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (parsInf != null) {
      return parsInf(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_ParsInf implements FilteringParams {
  const factory FilteringParams_ParsInf(final int field0) =
      _$FilteringParams_ParsInfImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$FilteringParams_ParsInfImplCopyWith<_$FilteringParams_ParsInfImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FilteringParams_PercInfImplCopyWith<$Res> {
  factory _$$FilteringParams_PercInfImplCopyWith(
          _$FilteringParams_PercInfImpl value,
          $Res Function(_$FilteringParams_PercInfImpl) then) =
      __$$FilteringParams_PercInfImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$FilteringParams_PercInfImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_PercInfImpl>
    implements _$$FilteringParams_PercInfImplCopyWith<$Res> {
  __$$FilteringParams_PercInfImplCopyWithImpl(
      _$FilteringParams_PercInfImpl _value,
      $Res Function(_$FilteringParams_PercInfImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FilteringParams_PercInfImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$FilteringParams_PercInfImpl implements FilteringParams_PercInf {
  const _$FilteringParams_PercInfImpl(this.field0);

  @override
  final double field0;

  @override
  String toString() {
    return 'FilteringParams.percInf(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_PercInfImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FilteringParams_PercInfImplCopyWith<_$FilteringParams_PercInfImpl>
      get copyWith => __$$FilteringParams_PercInfImplCopyWithImpl<
          _$FilteringParams_PercInfImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(int field0) alnLen,
    required TResult Function(int field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return percInf(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(int field0)? alnLen,
    TResult? Function(int field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return percInf?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(int field0)? alnLen,
    TResult Function(int field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (percInf != null) {
      return percInf(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return percInf(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return percInf?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (percInf != null) {
      return percInf(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_PercInf implements FilteringParams {
  const factory FilteringParams_PercInf(final double field0) =
      _$FilteringParams_PercInfImpl;

  double get field0;
  @JsonKey(ignore: true)
  _$$FilteringParams_PercInfImplCopyWith<_$FilteringParams_PercInfImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FilteringParams_TaxonAllImplCopyWith<$Res> {
  factory _$$FilteringParams_TaxonAllImplCopyWith(
          _$FilteringParams_TaxonAllImpl value,
          $Res Function(_$FilteringParams_TaxonAllImpl) then) =
      __$$FilteringParams_TaxonAllImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> field0});
}

/// @nodoc
class __$$FilteringParams_TaxonAllImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_TaxonAllImpl>
    implements _$$FilteringParams_TaxonAllImplCopyWith<$Res> {
  __$$FilteringParams_TaxonAllImplCopyWithImpl(
      _$FilteringParams_TaxonAllImpl _value,
      $Res Function(_$FilteringParams_TaxonAllImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FilteringParams_TaxonAllImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$FilteringParams_TaxonAllImpl implements FilteringParams_TaxonAll {
  const _$FilteringParams_TaxonAllImpl(final List<String> field0)
      : _field0 = field0;

  final List<String> _field0;
  @override
  List<String> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'FilteringParams.taxonAll(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_TaxonAllImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FilteringParams_TaxonAllImplCopyWith<_$FilteringParams_TaxonAllImpl>
      get copyWith => __$$FilteringParams_TaxonAllImplCopyWithImpl<
          _$FilteringParams_TaxonAllImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(int field0) alnLen,
    required TResult Function(int field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return taxonAll(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(int field0)? alnLen,
    TResult? Function(int field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return taxonAll?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(int field0)? alnLen,
    TResult Function(int field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (taxonAll != null) {
      return taxonAll(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return taxonAll(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return taxonAll?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (taxonAll != null) {
      return taxonAll(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_TaxonAll implements FilteringParams {
  const factory FilteringParams_TaxonAll(final List<String> field0) =
      _$FilteringParams_TaxonAllImpl;

  List<String> get field0;
  @JsonKey(ignore: true)
  _$$FilteringParams_TaxonAllImplCopyWith<_$FilteringParams_TaxonAllImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FilteringParams_NoneImplCopyWith<$Res> {
  factory _$$FilteringParams_NoneImplCopyWith(_$FilteringParams_NoneImpl value,
          $Res Function(_$FilteringParams_NoneImpl) then) =
      __$$FilteringParams_NoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FilteringParams_NoneImplCopyWithImpl<$Res>
    extends _$FilteringParamsCopyWithImpl<$Res, _$FilteringParams_NoneImpl>
    implements _$$FilteringParams_NoneImplCopyWith<$Res> {
  __$$FilteringParams_NoneImplCopyWithImpl(_$FilteringParams_NoneImpl _value,
      $Res Function(_$FilteringParams_NoneImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FilteringParams_NoneImpl implements FilteringParams_None {
  const _$FilteringParams_NoneImpl();

  @override
  String toString() {
    return 'FilteringParams.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FilteringParams_NoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double field0) minTax,
    required TResult Function(int field0) alnLen,
    required TResult Function(int field0) parsInf,
    required TResult Function(double field0) percInf,
    required TResult Function(List<String> field0) taxonAll,
    required TResult Function() none,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double field0)? minTax,
    TResult? Function(int field0)? alnLen,
    TResult? Function(int field0)? parsInf,
    TResult? Function(double field0)? percInf,
    TResult? Function(List<String> field0)? taxonAll,
    TResult? Function()? none,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double field0)? minTax,
    TResult Function(int field0)? alnLen,
    TResult Function(int field0)? parsInf,
    TResult Function(double field0)? percInf,
    TResult Function(List<String> field0)? taxonAll,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FilteringParams_MinTax value) minTax,
    required TResult Function(FilteringParams_AlnLen value) alnLen,
    required TResult Function(FilteringParams_ParsInf value) parsInf,
    required TResult Function(FilteringParams_PercInf value) percInf,
    required TResult Function(FilteringParams_TaxonAll value) taxonAll,
    required TResult Function(FilteringParams_None value) none,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FilteringParams_MinTax value)? minTax,
    TResult? Function(FilteringParams_AlnLen value)? alnLen,
    TResult? Function(FilteringParams_ParsInf value)? parsInf,
    TResult? Function(FilteringParams_PercInf value)? percInf,
    TResult? Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult? Function(FilteringParams_None value)? none,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FilteringParams_MinTax value)? minTax,
    TResult Function(FilteringParams_AlnLen value)? alnLen,
    TResult Function(FilteringParams_ParsInf value)? parsInf,
    TResult Function(FilteringParams_PercInf value)? percInf,
    TResult Function(FilteringParams_TaxonAll value)? taxonAll,
    TResult Function(FilteringParams_None value)? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class FilteringParams_None implements FilteringParams {
  const factory FilteringParams_None() = _$FilteringParams_NoneImpl;
}

/// @nodoc
mixin _$SequenceExtractionParams {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> field0) id,
    required TResult Function(String field0) file,
    required TResult Function(String field0) regex,
    required TResult Function() none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> field0)? id,
    TResult? Function(String field0)? file,
    TResult? Function(String field0)? regex,
    TResult? Function()? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> field0)? id,
    TResult Function(String field0)? file,
    TResult Function(String field0)? regex,
    TResult Function()? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceExtractionParams_Id value) id,
    required TResult Function(SequenceExtractionParams_File value) file,
    required TResult Function(SequenceExtractionParams_Regex value) regex,
    required TResult Function(SequenceExtractionParams_None value) none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceExtractionParams_Id value)? id,
    TResult? Function(SequenceExtractionParams_File value)? file,
    TResult? Function(SequenceExtractionParams_Regex value)? regex,
    TResult? Function(SequenceExtractionParams_None value)? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceExtractionParams_Id value)? id,
    TResult Function(SequenceExtractionParams_File value)? file,
    TResult Function(SequenceExtractionParams_Regex value)? regex,
    TResult Function(SequenceExtractionParams_None value)? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SequenceExtractionParamsCopyWith<$Res> {
  factory $SequenceExtractionParamsCopyWith(SequenceExtractionParams value,
          $Res Function(SequenceExtractionParams) then) =
      _$SequenceExtractionParamsCopyWithImpl<$Res, SequenceExtractionParams>;
}

/// @nodoc
class _$SequenceExtractionParamsCopyWithImpl<$Res,
        $Val extends SequenceExtractionParams>
    implements $SequenceExtractionParamsCopyWith<$Res> {
  _$SequenceExtractionParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SequenceExtractionParams_IdImplCopyWith<$Res> {
  factory _$$SequenceExtractionParams_IdImplCopyWith(
          _$SequenceExtractionParams_IdImpl value,
          $Res Function(_$SequenceExtractionParams_IdImpl) then) =
      __$$SequenceExtractionParams_IdImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> field0});
}

/// @nodoc
class __$$SequenceExtractionParams_IdImplCopyWithImpl<$Res>
    extends _$SequenceExtractionParamsCopyWithImpl<$Res,
        _$SequenceExtractionParams_IdImpl>
    implements _$$SequenceExtractionParams_IdImplCopyWith<$Res> {
  __$$SequenceExtractionParams_IdImplCopyWithImpl(
      _$SequenceExtractionParams_IdImpl _value,
      $Res Function(_$SequenceExtractionParams_IdImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SequenceExtractionParams_IdImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$SequenceExtractionParams_IdImpl implements SequenceExtractionParams_Id {
  const _$SequenceExtractionParams_IdImpl(final List<String> field0)
      : _field0 = field0;

  final List<String> _field0;
  @override
  List<String> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'SequenceExtractionParams.id(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceExtractionParams_IdImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceExtractionParams_IdImplCopyWith<_$SequenceExtractionParams_IdImpl>
      get copyWith => __$$SequenceExtractionParams_IdImplCopyWithImpl<
          _$SequenceExtractionParams_IdImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> field0) id,
    required TResult Function(String field0) file,
    required TResult Function(String field0) regex,
    required TResult Function() none,
  }) {
    return id(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> field0)? id,
    TResult? Function(String field0)? file,
    TResult? Function(String field0)? regex,
    TResult? Function()? none,
  }) {
    return id?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> field0)? id,
    TResult Function(String field0)? file,
    TResult Function(String field0)? regex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (id != null) {
      return id(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceExtractionParams_Id value) id,
    required TResult Function(SequenceExtractionParams_File value) file,
    required TResult Function(SequenceExtractionParams_Regex value) regex,
    required TResult Function(SequenceExtractionParams_None value) none,
  }) {
    return id(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceExtractionParams_Id value)? id,
    TResult? Function(SequenceExtractionParams_File value)? file,
    TResult? Function(SequenceExtractionParams_Regex value)? regex,
    TResult? Function(SequenceExtractionParams_None value)? none,
  }) {
    return id?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceExtractionParams_Id value)? id,
    TResult Function(SequenceExtractionParams_File value)? file,
    TResult Function(SequenceExtractionParams_Regex value)? regex,
    TResult Function(SequenceExtractionParams_None value)? none,
    required TResult orElse(),
  }) {
    if (id != null) {
      return id(this);
    }
    return orElse();
  }
}

abstract class SequenceExtractionParams_Id implements SequenceExtractionParams {
  const factory SequenceExtractionParams_Id(final List<String> field0) =
      _$SequenceExtractionParams_IdImpl;

  List<String> get field0;
  @JsonKey(ignore: true)
  _$$SequenceExtractionParams_IdImplCopyWith<_$SequenceExtractionParams_IdImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceExtractionParams_FileImplCopyWith<$Res> {
  factory _$$SequenceExtractionParams_FileImplCopyWith(
          _$SequenceExtractionParams_FileImpl value,
          $Res Function(_$SequenceExtractionParams_FileImpl) then) =
      __$$SequenceExtractionParams_FileImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$SequenceExtractionParams_FileImplCopyWithImpl<$Res>
    extends _$SequenceExtractionParamsCopyWithImpl<$Res,
        _$SequenceExtractionParams_FileImpl>
    implements _$$SequenceExtractionParams_FileImplCopyWith<$Res> {
  __$$SequenceExtractionParams_FileImplCopyWithImpl(
      _$SequenceExtractionParams_FileImpl _value,
      $Res Function(_$SequenceExtractionParams_FileImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SequenceExtractionParams_FileImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SequenceExtractionParams_FileImpl
    implements SequenceExtractionParams_File {
  const _$SequenceExtractionParams_FileImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'SequenceExtractionParams.file(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceExtractionParams_FileImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceExtractionParams_FileImplCopyWith<
          _$SequenceExtractionParams_FileImpl>
      get copyWith => __$$SequenceExtractionParams_FileImplCopyWithImpl<
          _$SequenceExtractionParams_FileImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> field0) id,
    required TResult Function(String field0) file,
    required TResult Function(String field0) regex,
    required TResult Function() none,
  }) {
    return file(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> field0)? id,
    TResult? Function(String field0)? file,
    TResult? Function(String field0)? regex,
    TResult? Function()? none,
  }) {
    return file?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> field0)? id,
    TResult Function(String field0)? file,
    TResult Function(String field0)? regex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (file != null) {
      return file(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceExtractionParams_Id value) id,
    required TResult Function(SequenceExtractionParams_File value) file,
    required TResult Function(SequenceExtractionParams_Regex value) regex,
    required TResult Function(SequenceExtractionParams_None value) none,
  }) {
    return file(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceExtractionParams_Id value)? id,
    TResult? Function(SequenceExtractionParams_File value)? file,
    TResult? Function(SequenceExtractionParams_Regex value)? regex,
    TResult? Function(SequenceExtractionParams_None value)? none,
  }) {
    return file?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceExtractionParams_Id value)? id,
    TResult Function(SequenceExtractionParams_File value)? file,
    TResult Function(SequenceExtractionParams_Regex value)? regex,
    TResult Function(SequenceExtractionParams_None value)? none,
    required TResult orElse(),
  }) {
    if (file != null) {
      return file(this);
    }
    return orElse();
  }
}

abstract class SequenceExtractionParams_File
    implements SequenceExtractionParams {
  const factory SequenceExtractionParams_File(final String field0) =
      _$SequenceExtractionParams_FileImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$SequenceExtractionParams_FileImplCopyWith<
          _$SequenceExtractionParams_FileImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceExtractionParams_RegexImplCopyWith<$Res> {
  factory _$$SequenceExtractionParams_RegexImplCopyWith(
          _$SequenceExtractionParams_RegexImpl value,
          $Res Function(_$SequenceExtractionParams_RegexImpl) then) =
      __$$SequenceExtractionParams_RegexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$SequenceExtractionParams_RegexImplCopyWithImpl<$Res>
    extends _$SequenceExtractionParamsCopyWithImpl<$Res,
        _$SequenceExtractionParams_RegexImpl>
    implements _$$SequenceExtractionParams_RegexImplCopyWith<$Res> {
  __$$SequenceExtractionParams_RegexImplCopyWithImpl(
      _$SequenceExtractionParams_RegexImpl _value,
      $Res Function(_$SequenceExtractionParams_RegexImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SequenceExtractionParams_RegexImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SequenceExtractionParams_RegexImpl
    implements SequenceExtractionParams_Regex {
  const _$SequenceExtractionParams_RegexImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'SequenceExtractionParams.regex(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceExtractionParams_RegexImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceExtractionParams_RegexImplCopyWith<
          _$SequenceExtractionParams_RegexImpl>
      get copyWith => __$$SequenceExtractionParams_RegexImplCopyWithImpl<
          _$SequenceExtractionParams_RegexImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> field0) id,
    required TResult Function(String field0) file,
    required TResult Function(String field0) regex,
    required TResult Function() none,
  }) {
    return regex(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> field0)? id,
    TResult? Function(String field0)? file,
    TResult? Function(String field0)? regex,
    TResult? Function()? none,
  }) {
    return regex?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> field0)? id,
    TResult Function(String field0)? file,
    TResult Function(String field0)? regex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (regex != null) {
      return regex(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceExtractionParams_Id value) id,
    required TResult Function(SequenceExtractionParams_File value) file,
    required TResult Function(SequenceExtractionParams_Regex value) regex,
    required TResult Function(SequenceExtractionParams_None value) none,
  }) {
    return regex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceExtractionParams_Id value)? id,
    TResult? Function(SequenceExtractionParams_File value)? file,
    TResult? Function(SequenceExtractionParams_Regex value)? regex,
    TResult? Function(SequenceExtractionParams_None value)? none,
  }) {
    return regex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceExtractionParams_Id value)? id,
    TResult Function(SequenceExtractionParams_File value)? file,
    TResult Function(SequenceExtractionParams_Regex value)? regex,
    TResult Function(SequenceExtractionParams_None value)? none,
    required TResult orElse(),
  }) {
    if (regex != null) {
      return regex(this);
    }
    return orElse();
  }
}

abstract class SequenceExtractionParams_Regex
    implements SequenceExtractionParams {
  const factory SequenceExtractionParams_Regex(final String field0) =
      _$SequenceExtractionParams_RegexImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$SequenceExtractionParams_RegexImplCopyWith<
          _$SequenceExtractionParams_RegexImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceExtractionParams_NoneImplCopyWith<$Res> {
  factory _$$SequenceExtractionParams_NoneImplCopyWith(
          _$SequenceExtractionParams_NoneImpl value,
          $Res Function(_$SequenceExtractionParams_NoneImpl) then) =
      __$$SequenceExtractionParams_NoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SequenceExtractionParams_NoneImplCopyWithImpl<$Res>
    extends _$SequenceExtractionParamsCopyWithImpl<$Res,
        _$SequenceExtractionParams_NoneImpl>
    implements _$$SequenceExtractionParams_NoneImplCopyWith<$Res> {
  __$$SequenceExtractionParams_NoneImplCopyWithImpl(
      _$SequenceExtractionParams_NoneImpl _value,
      $Res Function(_$SequenceExtractionParams_NoneImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SequenceExtractionParams_NoneImpl
    implements SequenceExtractionParams_None {
  const _$SequenceExtractionParams_NoneImpl();

  @override
  String toString() {
    return 'SequenceExtractionParams.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceExtractionParams_NoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> field0) id,
    required TResult Function(String field0) file,
    required TResult Function(String field0) regex,
    required TResult Function() none,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> field0)? id,
    TResult? Function(String field0)? file,
    TResult? Function(String field0)? regex,
    TResult? Function()? none,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> field0)? id,
    TResult Function(String field0)? file,
    TResult Function(String field0)? regex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceExtractionParams_Id value) id,
    required TResult Function(SequenceExtractionParams_File value) file,
    required TResult Function(SequenceExtractionParams_Regex value) regex,
    required TResult Function(SequenceExtractionParams_None value) none,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceExtractionParams_Id value)? id,
    TResult? Function(SequenceExtractionParams_File value)? file,
    TResult? Function(SequenceExtractionParams_Regex value)? regex,
    TResult? Function(SequenceExtractionParams_None value)? none,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceExtractionParams_Id value)? id,
    TResult Function(SequenceExtractionParams_File value)? file,
    TResult Function(SequenceExtractionParams_Regex value)? regex,
    TResult Function(SequenceExtractionParams_None value)? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class SequenceExtractionParams_None
    implements SequenceExtractionParams {
  const factory SequenceExtractionParams_None() =
      _$SequenceExtractionParams_NoneImpl;
}

/// @nodoc
mixin _$SequenceRenamingParams {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SequenceRenamingParamsCopyWith<$Res> {
  factory $SequenceRenamingParamsCopyWith(SequenceRenamingParams value,
          $Res Function(SequenceRenamingParams) then) =
      _$SequenceRenamingParamsCopyWithImpl<$Res, SequenceRenamingParams>;
}

/// @nodoc
class _$SequenceRenamingParamsCopyWithImpl<$Res,
        $Val extends SequenceRenamingParams>
    implements $SequenceRenamingParamsCopyWith<$Res> {
  _$SequenceRenamingParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_RenameIdImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_RenameIdImplCopyWith(
          _$SequenceRenamingParams_RenameIdImpl value,
          $Res Function(_$SequenceRenamingParams_RenameIdImpl) then) =
      __$$SequenceRenamingParams_RenameIdImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$SequenceRenamingParams_RenameIdImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_RenameIdImpl>
    implements _$$SequenceRenamingParams_RenameIdImplCopyWith<$Res> {
  __$$SequenceRenamingParams_RenameIdImplCopyWithImpl(
      _$SequenceRenamingParams_RenameIdImpl _value,
      $Res Function(_$SequenceRenamingParams_RenameIdImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SequenceRenamingParams_RenameIdImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SequenceRenamingParams_RenameIdImpl
    implements SequenceRenamingParams_RenameId {
  const _$SequenceRenamingParams_RenameIdImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'SequenceRenamingParams.renameId(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_RenameIdImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceRenamingParams_RenameIdImplCopyWith<
          _$SequenceRenamingParams_RenameIdImpl>
      get copyWith => __$$SequenceRenamingParams_RenameIdImplCopyWithImpl<
          _$SequenceRenamingParams_RenameIdImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return renameId(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return renameId?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (renameId != null) {
      return renameId(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return renameId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return renameId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (renameId != null) {
      return renameId(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_RenameId
    implements SequenceRenamingParams {
  const factory SequenceRenamingParams_RenameId(final String field0) =
      _$SequenceRenamingParams_RenameIdImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$SequenceRenamingParams_RenameIdImplCopyWith<
          _$SequenceRenamingParams_RenameIdImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_RemoveStrImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_RemoveStrImplCopyWith(
          _$SequenceRenamingParams_RemoveStrImpl value,
          $Res Function(_$SequenceRenamingParams_RemoveStrImpl) then) =
      __$$SequenceRenamingParams_RemoveStrImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$SequenceRenamingParams_RemoveStrImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_RemoveStrImpl>
    implements _$$SequenceRenamingParams_RemoveStrImplCopyWith<$Res> {
  __$$SequenceRenamingParams_RemoveStrImplCopyWithImpl(
      _$SequenceRenamingParams_RemoveStrImpl _value,
      $Res Function(_$SequenceRenamingParams_RemoveStrImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SequenceRenamingParams_RemoveStrImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SequenceRenamingParams_RemoveStrImpl
    implements SequenceRenamingParams_RemoveStr {
  const _$SequenceRenamingParams_RemoveStrImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'SequenceRenamingParams.removeStr(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_RemoveStrImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceRenamingParams_RemoveStrImplCopyWith<
          _$SequenceRenamingParams_RemoveStrImpl>
      get copyWith => __$$SequenceRenamingParams_RemoveStrImplCopyWithImpl<
          _$SequenceRenamingParams_RemoveStrImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return removeStr(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return removeStr?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (removeStr != null) {
      return removeStr(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return removeStr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return removeStr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (removeStr != null) {
      return removeStr(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_RemoveStr
    implements SequenceRenamingParams {
  const factory SequenceRenamingParams_RemoveStr(final String field0) =
      _$SequenceRenamingParams_RemoveStrImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$SequenceRenamingParams_RemoveStrImplCopyWith<
          _$SequenceRenamingParams_RemoveStrImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_RemoveRegexImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_RemoveRegexImplCopyWith(
          _$SequenceRenamingParams_RemoveRegexImpl value,
          $Res Function(_$SequenceRenamingParams_RemoveRegexImpl) then) =
      __$$SequenceRenamingParams_RemoveRegexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0, bool field1});
}

/// @nodoc
class __$$SequenceRenamingParams_RemoveRegexImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_RemoveRegexImpl>
    implements _$$SequenceRenamingParams_RemoveRegexImplCopyWith<$Res> {
  __$$SequenceRenamingParams_RemoveRegexImplCopyWithImpl(
      _$SequenceRenamingParams_RemoveRegexImpl _value,
      $Res Function(_$SequenceRenamingParams_RemoveRegexImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$SequenceRenamingParams_RemoveRegexImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$SequenceRenamingParams_RemoveRegexImpl
    implements SequenceRenamingParams_RemoveRegex {
  const _$SequenceRenamingParams_RemoveRegexImpl(this.field0, this.field1);

  @override
  final String field0;
  @override
  final bool field1;

  @override
  String toString() {
    return 'SequenceRenamingParams.removeRegex(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_RemoveRegexImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceRenamingParams_RemoveRegexImplCopyWith<
          _$SequenceRenamingParams_RemoveRegexImpl>
      get copyWith => __$$SequenceRenamingParams_RemoveRegexImplCopyWithImpl<
          _$SequenceRenamingParams_RemoveRegexImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return removeRegex(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return removeRegex?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (removeRegex != null) {
      return removeRegex(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return removeRegex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return removeRegex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (removeRegex != null) {
      return removeRegex(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_RemoveRegex
    implements SequenceRenamingParams {
  const factory SequenceRenamingParams_RemoveRegex(
          final String field0, final bool field1) =
      _$SequenceRenamingParams_RemoveRegexImpl;

  String get field0;
  bool get field1;
  @JsonKey(ignore: true)
  _$$SequenceRenamingParams_RemoveRegexImplCopyWith<
          _$SequenceRenamingParams_RemoveRegexImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_ReplaceStrImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_ReplaceStrImplCopyWith(
          _$SequenceRenamingParams_ReplaceStrImpl value,
          $Res Function(_$SequenceRenamingParams_ReplaceStrImpl) then) =
      __$$SequenceRenamingParams_ReplaceStrImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0, String field1});
}

/// @nodoc
class __$$SequenceRenamingParams_ReplaceStrImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_ReplaceStrImpl>
    implements _$$SequenceRenamingParams_ReplaceStrImplCopyWith<$Res> {
  __$$SequenceRenamingParams_ReplaceStrImplCopyWithImpl(
      _$SequenceRenamingParams_ReplaceStrImpl _value,
      $Res Function(_$SequenceRenamingParams_ReplaceStrImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$SequenceRenamingParams_ReplaceStrImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SequenceRenamingParams_ReplaceStrImpl
    implements SequenceRenamingParams_ReplaceStr {
  const _$SequenceRenamingParams_ReplaceStrImpl(this.field0, this.field1);

  @override
  final String field0;
  @override
  final String field1;

  @override
  String toString() {
    return 'SequenceRenamingParams.replaceStr(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_ReplaceStrImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceRenamingParams_ReplaceStrImplCopyWith<
          _$SequenceRenamingParams_ReplaceStrImpl>
      get copyWith => __$$SequenceRenamingParams_ReplaceStrImplCopyWithImpl<
          _$SequenceRenamingParams_ReplaceStrImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return replaceStr(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return replaceStr?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (replaceStr != null) {
      return replaceStr(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return replaceStr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return replaceStr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (replaceStr != null) {
      return replaceStr(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_ReplaceStr
    implements SequenceRenamingParams {
  const factory SequenceRenamingParams_ReplaceStr(
          final String field0, final String field1) =
      _$SequenceRenamingParams_ReplaceStrImpl;

  String get field0;
  String get field1;
  @JsonKey(ignore: true)
  _$$SequenceRenamingParams_ReplaceStrImplCopyWith<
          _$SequenceRenamingParams_ReplaceStrImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_ReplaceRegexImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_ReplaceRegexImplCopyWith(
          _$SequenceRenamingParams_ReplaceRegexImpl value,
          $Res Function(_$SequenceRenamingParams_ReplaceRegexImpl) then) =
      __$$SequenceRenamingParams_ReplaceRegexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0, String field1, bool field2});
}

/// @nodoc
class __$$SequenceRenamingParams_ReplaceRegexImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_ReplaceRegexImpl>
    implements _$$SequenceRenamingParams_ReplaceRegexImplCopyWith<$Res> {
  __$$SequenceRenamingParams_ReplaceRegexImplCopyWithImpl(
      _$SequenceRenamingParams_ReplaceRegexImpl _value,
      $Res Function(_$SequenceRenamingParams_ReplaceRegexImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
    Object? field2 = null,
  }) {
    return _then(_$SequenceRenamingParams_ReplaceRegexImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
      null == field2
          ? _value.field2
          : field2 // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$SequenceRenamingParams_ReplaceRegexImpl
    implements SequenceRenamingParams_ReplaceRegex {
  const _$SequenceRenamingParams_ReplaceRegexImpl(
      this.field0, this.field1, this.field2);

  @override
  final String field0;
  @override
  final String field1;
  @override
  final bool field2;

  @override
  String toString() {
    return 'SequenceRenamingParams.replaceRegex(field0: $field0, field1: $field1, field2: $field2)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_ReplaceRegexImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1) &&
            (identical(other.field2, field2) || other.field2 == field2));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1, field2);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SequenceRenamingParams_ReplaceRegexImplCopyWith<
          _$SequenceRenamingParams_ReplaceRegexImpl>
      get copyWith => __$$SequenceRenamingParams_ReplaceRegexImplCopyWithImpl<
          _$SequenceRenamingParams_ReplaceRegexImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return replaceRegex(field0, field1, field2);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return replaceRegex?.call(field0, field1, field2);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (replaceRegex != null) {
      return replaceRegex(field0, field1, field2);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return replaceRegex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return replaceRegex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (replaceRegex != null) {
      return replaceRegex(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_ReplaceRegex
    implements SequenceRenamingParams {
  const factory SequenceRenamingParams_ReplaceRegex(
          final String field0, final String field1, final bool field2) =
      _$SequenceRenamingParams_ReplaceRegexImpl;

  String get field0;
  String get field1;
  bool get field2;
  @JsonKey(ignore: true)
  _$$SequenceRenamingParams_ReplaceRegexImplCopyWith<
          _$SequenceRenamingParams_ReplaceRegexImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SequenceRenamingParams_NoneImplCopyWith<$Res> {
  factory _$$SequenceRenamingParams_NoneImplCopyWith(
          _$SequenceRenamingParams_NoneImpl value,
          $Res Function(_$SequenceRenamingParams_NoneImpl) then) =
      __$$SequenceRenamingParams_NoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SequenceRenamingParams_NoneImplCopyWithImpl<$Res>
    extends _$SequenceRenamingParamsCopyWithImpl<$Res,
        _$SequenceRenamingParams_NoneImpl>
    implements _$$SequenceRenamingParams_NoneImplCopyWith<$Res> {
  __$$SequenceRenamingParams_NoneImplCopyWithImpl(
      _$SequenceRenamingParams_NoneImpl _value,
      $Res Function(_$SequenceRenamingParams_NoneImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SequenceRenamingParams_NoneImpl implements SequenceRenamingParams_None {
  const _$SequenceRenamingParams_NoneImpl();

  @override
  String toString() {
    return 'SequenceRenamingParams.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SequenceRenamingParams_NoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) renameId,
    required TResult Function(String field0) removeStr,
    required TResult Function(String field0, bool field1) removeRegex,
    required TResult Function(String field0, String field1) replaceStr,
    required TResult Function(String field0, String field1, bool field2)
        replaceRegex,
    required TResult Function() none,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? renameId,
    TResult? Function(String field0)? removeStr,
    TResult? Function(String field0, bool field1)? removeRegex,
    TResult? Function(String field0, String field1)? replaceStr,
    TResult? Function(String field0, String field1, bool field2)? replaceRegex,
    TResult? Function()? none,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? renameId,
    TResult Function(String field0)? removeStr,
    TResult Function(String field0, bool field1)? removeRegex,
    TResult Function(String field0, String field1)? replaceStr,
    TResult Function(String field0, String field1, bool field2)? replaceRegex,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SequenceRenamingParams_RenameId value) renameId,
    required TResult Function(SequenceRenamingParams_RemoveStr value) removeStr,
    required TResult Function(SequenceRenamingParams_RemoveRegex value)
        removeRegex,
    required TResult Function(SequenceRenamingParams_ReplaceStr value)
        replaceStr,
    required TResult Function(SequenceRenamingParams_ReplaceRegex value)
        replaceRegex,
    required TResult Function(SequenceRenamingParams_None value) none,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult? Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult? Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult? Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult? Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult? Function(SequenceRenamingParams_None value)? none,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SequenceRenamingParams_RenameId value)? renameId,
    TResult Function(SequenceRenamingParams_RemoveStr value)? removeStr,
    TResult Function(SequenceRenamingParams_RemoveRegex value)? removeRegex,
    TResult Function(SequenceRenamingParams_ReplaceStr value)? replaceStr,
    TResult Function(SequenceRenamingParams_ReplaceRegex value)? replaceRegex,
    TResult Function(SequenceRenamingParams_None value)? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class SequenceRenamingParams_None implements SequenceRenamingParams {
  const factory SequenceRenamingParams_None() =
      _$SequenceRenamingParams_NoneImpl;
}
